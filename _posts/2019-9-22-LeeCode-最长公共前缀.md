---
layout:     post
title:      LeetCode-最长公共前缀
subtitle:   LeetCode/
date:       2019-9-22
author:     Yifeng
header-img: img/post-leetcode-easy.jpg
catalog: true
tags:
     - Oj/LeetCode
---



## 题目

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。



## 示例

```
输入: ["flower","flow","flight"]
输出: "fl"

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明:**

所有输入只包含小写字母 `a-z` 。



## 解决方案

### 方案一：我想到的暴力解法     

​     首先考虑特殊情况，当一个数组为空时肯定返回空；当数组内只有一个元素时返回这个元素；当数组有大于等于两个元素的时候就需要进行遍历判断。第一中方法采用的是暴力遍历，首先我们找出数组中长度最短的那个，然后依次判断其它元素中的第i位是否和最短元素的第i位相同，一直到出现一个不相同或者将最短元素遍历完就结束了。

```c++
class Solution {
public:

    bool max(string a,string b){
        return a.size()<b.size();
    }
    string longestCommonPrefix(vector<string>& strs) {

        string result="";
        //处理特殊情况
        if(strs.size()==0)
            return result;
        else if(strs.size()==1)
            return strs[0];
        else{
            bool flag;
            //求出最短的那个字符串
            sort(strs.begin(),strs.end(),[](string x,string y){return x.length()<y.length();});
            string minLength=strs[0];
            //遍历
            for(int i=0;i<minLength.size();i++){
                flag=true;
                for(int j=1;j<strs.size();j++){
                    if(strs[j].at(i)!= minLength.at(i)){
                        flag=false;
                    }

                }
                if(flag)
                    result+=minLength.at(i);
                else
                    return result;

            }
            return result;

        }
    }
};
```

### 方案二：水平扫描法

​      这种方法和我的方法差不多，但是之所以写这种方法是因为：官方的这种解法很巧妙的将我的解法颠倒了过来，它不是从某个字符串的第一个开始比，相反的它先将第一个字符串作为公共子串进行验证，如果不是那么就进行截取，后继续进行判断，直到出现了空串或者遍历完就结束了。

![](https://i.loli.net/2019/09/22/wnEAYyePctg4RSB.png)

```c++
class Solution {
public:

    bool max(string a,string b){
        return a.size()<b.size();
    }
    string longestCommonPrefix(vector<string>& strs) {


        if(strs.size()==0)
            return "";
        else if(strs.size()==1)
            return strs[0];
        else{
            bool flag;
            sort(strs.begin(),strs.end(),[](string x,string y){return x.length()<y.length();});
            string minLength=strs[0];
            for(int i=1;i<strs.size();i++){
                while(strs[i].find(minLength)!=0){
                    minLength=minLength.substr(0,minLength.size()-1);
                    if(minLength.size()==0) return "";
                }

            }
            return minLength;

        }
    }
};
```

