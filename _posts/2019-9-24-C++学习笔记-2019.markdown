---
layout:     post
title:      C++学习笔记
subtitle:   还在更新
date:       2019-9-23
author:     Yifeng
header-img: img/post-c++.jpg
catalog: true
tags:
     -学习笔记
---





# C++ Primer学习笔记

## 第一章  开始

### 注意事项

1. `<<` 运算符返回的是符号左边的对象，所以我们可以使用`cout<<"the number is"<<result<<endl;`这样的语句；`>>`也具有这样的性质

2. `endl` 是一个操纵符，它的作用是结束当前行，并把输出缓冲区中的所有信息输出到设备中。

   > 在调试时添加的打印语句应当保证“一直”在刷新，否则，如果程序崩溃，输出可能还在缓冲区中，从而导致关于程序崩溃位置的错误推断

3. `while(cin>>value)`  可以输入未知个数的值，因为`>>`运算符返回左侧的对象`cin`，所以这个循环的条件时判断`cin`的有效状态，当输入流输入一个`value`l类型的数据的时候，`cin`为有效‘；当遇到**文件结束符**或者输入一个不是`value`类型的数据的时候就会变成无效状态。

   > Windows中输入结束符为`Ctrl+C`,Linux和Unix中输入结束符为`Ctrl+D`

4. 标准库中的头文件用`<>`，非标准库中的头文件使用`""`

5. `cerr` 的输出对象是不缓冲的，用于输出错误信息。



## 第二章 变量和基本类型

#### 选择类型时的一些经验准则

- 当明确知道类型不可能为负时，选用无符号型
- 使用`int`进行计算。实际应用中，`short`常常太小，`long`和`intd`的范围又常常是一样的，所以如果`int`的范围不够的话，选用`long long`
- 算数表达式中尽量不要用`char`,因为在有些机器上`char`为有符号的，在有一些机器上`cahr`为无符号的
- 执行浮点数运算使用`double`,因为`double`和`float`占用的空间和计算的速度都差不多。

​    

#### 强制类型转换时应当注意的

- `int`转化为`bool`时，非0的全部为`true`，只有0为`false`；
- `bool`转化为`int`时，`false`转化为0，`true`转化为1
- `double`转化为`int`时，直接取小数点以前的位
- **带符号的类型超过其表示范围时，结果是未定义的**



#### 无符号数

- **无符号数不要和有符号数混用**，因为有符号数和无符号数运行前，会先进行类型转换，如果有符号数为负数，那么在转化为无符号数的时候就会出现差错，从而导致结果不正确
- 无符号数减去一个数时，无论这个数是不是无符号数，都要确保结果不是负数



> 初始化不是赋值，初始化是创建变量的时候赋予其一个初始值；而赋值是指把对象的当前值擦除掉，以一个新值来代替

#### 默认初始化

  如果定义变量时没有指定初值，则变量被默认初始化。默认初始化的值与变量定义的位置有关，定义于任何函数体制外的变量被初始化为0，**在函数体内部的内置类型变量将不被初始化，它的值是未被定义的**。



#### 声明与定义

   C++语言将声明与定义区分开来。声明使得名字被程序所知道；定义负责创建与名字关联的实体。声明与定义主要有以下区别：

- 一个变量只能够被定义一次，但是可以被声明多次
- 声明时程序不会给变量分配内存空间，所以也无法初始化；定义时程序会给内存分配空间，可以初始化 

  想要声明一个变量，则使用`extern`关键词

```c++
wxtern int i;//声明一个变量，不可以初始化
```

  **在函数体内部声明变量时不可以初始化，否则会报错**

> 声明和定义分开主要适用于多个文件，当多个文件要使用同一个变量的时候，就需要将声明与定义分开



#### 标识符

   C++中的标识符以数字、下划线、字母组成，其中有以下几个注意的地方：

- 在函数外定义的标识符不可以以下划线开头
- 不可以以下划线紧连着大写字母开头
- 不能够出现连续两个下划线

#### 作用域

   如果函数内部定义了与函数外部同名的变量，则在函数内部访问时，优先访问函数内部的变量，也就是外部的变量被暂时覆盖掉了，但是也可以通过命名空间来访问外部的变量。

 ```c++
#include<iostream>
using namespace std;
int reused=10;
int main(){
		int reused=1;
		cout<<reused<<endl;//输出1
    	cout<<::reused>>endl;//输出10
		return 0;
}
 ```

  上面的那段代码通过使用全部变量的命名空间`::`来访问全局变量。

#### 引用

   引用其实是对变量起一个别名，引用是一种类型，通过将声明符写为`&x`来定义引用类型。

```c++
int d;
int &c=d;//c是d的一个别名
int &p;//错误，引用必须初始化
```

   引用类型在定义的时候必须被初始化。

   **因为引用不是对象，所以不能够定义引用的引用**，引用只能是某个变量的引用，而不能够是某个`字面值`的引用。

```c++
int &p=10;//错误

double x=3.01;
int &m=x;//错误只能够引用同类型的变量
```

   **引用类型必须和被引用对象的类型相同，但是此处存在两个意外**:

- 当是常量引用时允许使用任意表达式作为初始值，只要该表达式能够转化为所引用的类型就可以

  ```c++
  const int &a=20;//正确
  double b=2.01;
  const int &c=b;//正确
  ```

  要想理解为什么是正确的，就必须了解编译器在处理的时候是如何处理的：

  ```c++
  /*
  *对于const int &a=20编译器的处理步骤
  */
  
  const int temp=20;
  const int &a=temp;
  ```

  ​      编译器创建了一个临时量对象，然后将引用绑定到这个临时量上，因为是常量引用，所以不可以修改值也就不会出现问题。

  ​     但是如果不是常量引用，我们定义一个变量的引用当然是为了通过引用的变量去修改原来的值，`double a=1.2; int &p=a;`，我们希望通过修改`p`的值来修改`a`的值，但是编译器在处理的时候，`p`绑定的不是`a`，而是创建的临时变量，所以并不能通过修改`p`的值来修改`a`的值，这不是程序员希望看到的，所以编译器将这种形式的定义判定为非法的。



#### 指针

   指针与引用的不同：

- 指针本事就是一个对象，允许对指针进行赋值、拷贝，而且在生命周期种也可以先后指向几个不同的对象
- 指针无需再定义的时候初始化

> 因为引用不是对象，所以不能够定义指向引用的指针。

  指针必须与指向对象的类型相匹配，因为声明语句中指针的类型其实用来确定指针所指向内容的类型，所以必须相互匹配。

```c++
double p=0.2;
int *m=&p;//错误，指针的类型与指向内容的类型不同
```

**理解复合类型的声明**

​     在 `int* p`中类型修饰符`*`修饰的是`p`而不是`int`，也就是说基本数据类型是`int`，`*`只是修饰了`p`而已，对该语句中的其他变量并不起作用。

```c++
int *p,x;//其中p为指针类型，x为int类型
```

  引用不是一个对象，因此没有指向引用的指针；但是指针是一个对象，因此存在指针的引用。

```c++
int p,*q=p;
int *&m=q;
```

  m是一个指针的引用。**要理解m的类型是什么，可以采用从右向左阅读m的定义。离变量名最近的符号对变量的类型有最直接的影响，因此m是一个引用，然后是\*，说明m是一个指针的引用，最后是int，说明是一个整型指针的引用。

　　**对于比较复杂的定义，采用从右到左的观察方法可以有利于判断变量的类型**

#### const限定符

   `const`限定符用来定义常量，由于它的值一旦确定就无法改变，所以必须在创建的时候初始化。

   对于`const int p=100;`，在编译的时候，编译器将用到改变了的地方全部用100代替，也就是说编译器会找到代码中所有使用p的位置，并用相应的值100替换。为了执行上面的替换，编译器必须知道变量的初始值，如果程序包含多个文件则每个文件内必须定义，为了能够在不同的文件中定义，默认情况下**`const`只在文件内有效**，当多个文件中出现了同名的`const`变量时，其实是在不同的文件中定义了独立的变量。

   但是有的时候却想共享`const`变量，这时候就需要用`extern`

```c++
extern const int a=10;
```

​    如果想要让`const`变量能像其它变量一样，能够在不同文件之间共享，就必须在`const`变量定义时加上`extern`关键字。

  **常量引用只对引用本身做出了限制，对所引用对象是没有做出限制的**

```c++
int p=2;
const int &m=p;//m的值不可以改变，即不能够对m进行任何会改变值的操作
p=3;//这时m的值也变为3，m是p的引用，m会随着p改变
```



#### const和指针

​         `const`和指针搭配一共有4种类型：

1.  `const int *p`：首先`*p`表明`p`是一个指针，另外`const int`表明，它是一个指向的只一个整型常量，也就是不可以对`*p`赋值。

   ```c++
   int p=2;
   const int *m=&p;
   *m=20;//错误，不能够对*m赋值
   ```

2. `int * const p`：`const p`表明`p`是一个常量，`p`里面存储的内容不可以被修改，`int *`表示是一个指向整型的指针.

   ```c++
   int p=1,q=2;
   int * const m&p;
   *m=32;//正确，因为没有修改m内存储的地址
   m=&q;//错误，因为m是一个常量，地址的值不可以被修改
   int * const n;//错误，因为指针是一个常量，所以必须在定义的时候初始化
   ```

3. `int const *p`和`const int *p`一样

4. `int const * const p`：地址不可变，指向的对象也不可变

> 所谓指向常量的指针，只是让指针自己以为自己指向的是常量，从而不允许自己做修改值的操作，但是所指向的对象本身可能不是常量。



#### 处理类型

​    除了使用`typedef`定义类型别名外，还可以使用`using`

```c++
typedef int L;
using L=int;
```

   这两个语句是等价的。