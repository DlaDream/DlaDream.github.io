---
layout:     post
title:      Linux-处理机管理
subtitle:   关于Linux处理机的相关复习
date:       2019-12-12
author:     DlaDream
header-img: img/post-bg-kuaidi.jpg
catalog: true
tags:
     - Linux

---

## 第二章 处理机管理

> 在Linux中提高处理机利用率的方法是引入了多道和分时。
> 
> 同时引入进程的概念，进程并发执行，操作系统通过控制使系统资源得到充分地使用。

### 作业

  作业是用户向系统提供一项工作的基本单位。

**作业VS进程**

   动态性：作业是用户向操作系统提供任务的基本单位，是计算机在一次任务处理中所作的工作总和；而进程是关于某个数据集合的一次运行活动，是操作系统分配资源的基本单位

   层次性：作业是是用户向系统提交任务的任务实体；而进程是作业被调度后系统为作业创建的执行实体，它们处于不同的层次：作业描述的是用户和操作系统之间的委托关系，而进程描述的是操作系统内部任务的具体执行过程

   一个作业被提交后，必须以进程的形式具体完成

   依赖性：作业经过一次宏观调度从外存进入内存，以进程的形式运行。在**Linux/Unix系统中无宏观调度**，作业直接进入内存以进程的形式运行。

   一个作业可以有几个进程构成

根据系统对作业的响应特征，可以将作业分为：

- 前台作业：输入后必须立即得到响应，等到该作业执行完后才可以执行下一个作业

- 后台作业：不需要得到系统的及时响应；在Linux中输入作业后加入`&`就可指定该作业为后台作业

### 进程

   资源分配的基本单位；进程之间是**相互制约，相互依赖**的关系

> 程序是指令的集合，是静态的概念；而进程是针对某组数据的一次执行过程，是动态的概念
> 
> 一个程序可能对应很多进程；一个进程也可以包含很多程序

#### 进程的描述

   进程分为内核态(0)和用户态(3)

每个Linux进程在内存中拥有以下数据：

- 代码段：存储程序的代码

- 堆栈段：存储子程序的返回地址、子程序的参数以及程序的局部变量

- 数据段：存储程序的全局变量，常数
  
  如果操作系统中同时运行多个同一程序，那么可以用一个代码段，但是不能用一个堆栈段和数据段

> 内存：分为以下几个部分
> 
> 栈：存放程序的参数值、局部变量等，由编译器自己分配和释放
> 
> 堆：通过new、malloc分配的数据块，编译器不负责释放工作，由程序段完成释放
> 
> 静态区：全局变量和静态变量，程序结束后由系统释放
> 
> 常量区：常量存储在该区，不允许修改
> 
> 代码区：存储函数代码的二进制格式

---

**Linux进程的四要素**

- 程序

- 进程控制块

- 地址空间

- 系统堆栈空间:系统在核心态所使用的堆栈

---

  系统中的进程个数是有限的，所有进程的PCB及系统堆栈占用的空间(共8KB)<=物理内存总和的1/2；比如：64M内存，则进程数量<=(64/2)/8=4K

##### 进程控制块

  在Linux中进程控制块就是task_struct结构，包括：描述信息、资源信息、控制信息、CPU现场保护结构。**task_struct由系统维护，用户不能够修改**

> task_struct的解释在[这篇文章](https://blog.csdn.net/gatieme/article/details/51383272)中有很详细的解释

###### 状态信息

| 名称                   | 含义                                                     |
|:--------------------:|:------------------------------------------------------:|
| TASK_RUNNING         | 处在就绪或者运行状态                                             |
| TASK_INTERRUPTIBLE   | 由于某些原因进程被阻塞，只要需要的条件(一般是信号)得到就进入就绪状态                    |
| TASK_UNINTERRUPTIBLE | 和TASK_INTERRUPTIBLE相似，不能够通过一个简单的信号唤醒，只有等待的资源可用的时候才会被唤醒 |
| TASK_STOPPED         | 进程被停止执行，通常是接收了一个信号                                     |
| TASK_ZOMBIE          | 进程被终止执行，但是父进程还没有使用wait()等系统调用获知它终止信息，成为僵尸进程            |
| TASK_EXCLUSIVE       | 独占状态，其实是等待状态的一种；但是当事件发生时只有该状态被激活，其它状态不会被激活             |

TASK_INTERRUPTIBLE是可中断状态，通常是接收一个信号后被中断；TASK_UNINTERRUPTIBLE不可中断状态

![](https://i.loli.net/2019/12/10/QtlSAaIyJpODm1B.png)

###### 身份信息

| 名称   | 含义         |
|:----:|:----------:|
| pid  | 进程标识       |
| uid  | 运行进程的用户标识  |
| gid  | 运行进程的用户组标识 |
| euid | 有效uid      |
| egid | 有效gid      |

###### 进程调度

优先级方面：

| 字段          | 描述                |
|:-----------:|:-----------------:|
| static_prio | 保存静态优先级，可以由nice修改 |
| rt_priority | 保存实时优先级           |
| prio        | 用于保存动态优先级         |
| normal_prio | 值取决于静态优先级和调度策略    |

| 字段          | 描述                                                                    |
|:-----------:|:---------------------------------------------------------------------:|
| priority    | 进程每次获得cpu后可以使用的时间(静态优先级)                                              |
| rt_priority | 实时优先级，rt_priority+100给出进程每次获取CPU后可以使用的时间                              |
| counter     | 在轮转法中表示进程当前还可以运行多久；在进程开始时被赋值为priority的值，每个tick(时钟)递减1，减到0重新调度。(动态优先级) |

  实时进程：1000+rt_priority

  分时进程：counter+20-nice

策略方面：

调度策略的字段为：`policy`，主要有以下几个策略

| 字段          | 描述                                                                |
|:-----------:|:-----------------------------------------------------------------:|
| SHCED_FIFO  | 先进先出                                                              |
| SCHED_RR    | 轮流调度算法，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。 |
| SCHED_OTHER | 其它                                                                |

> 其中SCHED_FIFO和SCHED_RR是实时进程，第三种为非实时进程

###### 进程标志

   进程标志字段为`flags`，主要有以下几种：

| 字段            | 描述        |
|:-------------:|:---------:|
| PF_ALIGNWARN  | 对齐警告      |
| PF_STARTING   | 正在创建进程    |
| PF_EXITING    | 进程正在退出    |
| PF_FORKNOEXEC | 进程刚创建还没执行 |
| PF_SIGNALED   | 进程被信号终止   |
| PF_SUPERRIV   | 超级用户权限    |
| PF_MEMALLOC   | 正在分配内存    |

###### ptrace系统调用

   提供了一个父进程可以控制子进程的运行，并可以检查和改变子进程。主要用于断点调试

| 字段          | 描述            |
|:-----------:|:-------------:|
| PF_DTRACED  | delayed trace |
| PF_TRACESYS | 正在跟踪          |
| PF_PTRACED  | 被ptrace系统调用监控 |

###### 进程队列指针

   **所有进程以PCB的形式组成一个双向链表。**

| 字段        | 描述      |
|:---------:|:-------:|
| next_task | 下一个任务   |
| prev_task | 上一个任务   |
| p_opptr   | 指向原始父进程 |
| p_pptr    | 指向父进程   |
| p_cptr    | 指向子进程   |
| p_ysptr   | 指向新兄弟进程 |
| p_osptr   | 指向老兄弟进程 |

![](C:\Users\薛定谔的猫\AppData\Roaming\marktext\images\2019-12-10-23-23-51-image.png)

#### 进程状态及转换

![](https://i.loli.net/2019/12/10/PrYyaUBVN3429FM.png)

#### 进程控制

   进程控制使用原语

##### fork

   fork函数创建一个新进程，对于父进程返回子进程的pid，对于子进程返回0

```cpp
k=fork()
if(k<0) //创建进程失败
{
    //code
}else if(k==0){ //子进程执行这个
        //code child to do    
}else{
    //父进程执行这个
}
```

 **对于fork的子程序，父进程的全局变量会传给子进程，但是子进程里面的值是父进程的一个copy，也就是说子进程修改了值但是不会回传给父进程，是单向传递**

#### 进程通信

   按照通信双方地位可以将通信分为以下几类：

- 主从式：操作系统中终端控制和终端进程之间采用这种方式

- 会话式：通信双方属于客户服务器类别

- 消息或邮箱机制

- 共享存储区
  
  Linux中提供了多种通信机制

| 名称            | 描述                                   |
|:-------------:|:------------------------------------:|
| 信号            | 主要用于进程之间实现互斥和同步                      |
| 管道            | 通过文件系统实现，包括有名管道和无名管道                 |
| UNIX system V | IPC通信机制，包括信号量、消息队列、共享内存              |
| 套接字           | 通过网络实现**在不同计算机上**进行通信的机制，可以实现数据的双向传递 |

##### 信号

  信号用于在进程之间传递控制信号，当程序处于**中断等待状态**时，可以用信号唤醒并进入就绪状态。

| 信号    | 描述                                   |
|:-----:|:------------------------------------:|
| 实时信号  | POSIX引入的信号类型，同一种信号可以排队，以确保发送的信号全部被接收 |
| 非实时信号 | 编号1-31，同一种信号不可以排队                    |

  信号保存task_struct的signal域中，类似一个链表。相应位置为1表示收到相应的信号；为0表示没有收到相应的信号。

> linux不提供处理多个同类信号的机制，即进程无法区分是接收到1个还是4个SINCONT信号
> 
> 信号并非一产生就处理，而是等到进程再次运行的时候再处理

  在进程的数据结构中存有该进程对信号的处理函数(可以用signal()设置，就是信号与函数的绑定):`signal(sig,func)`

| 数值   | 含义    | 描述      |
|:----:|:-----:|:-------:|
| 1    | 忽略    | 不处理该信号  |
| 其它数值 | 用户自定义 | 自定义函数处理 |
| 0    | 缺省    | 一般为进程退出 |

  信号的发送由系统调用`kill(pid,sig)`发送信号。并不是所有的进程都可以向其它所有进程发送信号。

> 只有核心进程和具有超级用户权限的继承才可以向其它进程发送信号。
> 
> 普通进程只可以向**相同uid和gid的进程或者同一进程组中的进程发送信号**

问题：如果信号产生时该进程在核心模式下运行，并且需要立刻返回使该进程进入核心态的用户模式下的进程。 

解决：操纵进程的堆栈寄存器。进程的程序计数器被设置为信号处理程序的地址，参数通过调用框架或者寄存器传入到处理程序中。当进程继续执行时，信号处理程序好像普通函数调用一样被执行。

##### 管道

管道分为有名管道和无名管道。

无名管道：利用`pipe()`创建，用返回的文件描述符标志该文件；只能够由调用`pipe()`的进程及其子进程可以使用。临时文件，存储在内存中。

![](https://i.loli.net/2019/12/11/b84xqWjv5F6uRyo.png)

有名管道：利用`mknod`或`mkfifo`创建，可以在文件系统中长期存在的具有路径名的文件，任何进程都可以利用路径名来访问该文件。对于有名管道的访问方式和对文件的访问方式类似，都是通过`open()`系统调用访问。永久性文件，存储在磁盘上。

> 系统将管道看作为循环队列，Linux系统会自动同步对管道的同步访问

Linux中管道通过指向同一个临时VFS indoe的两个file数据结构来实现，此VFS inode指向内存中的一个物理页面。(使管道的使用方式和文件的使用方式无差别)

![](https://i.loli.net/2019/12/11/VedhR2XgLumztBP.png)

管道读数据：

- 当管道中有数据时，进程便从读指针的位置开始读数据，每读一个数据，地址项自动增加，当读操作结束后由核心修改读指针，并唤醒所有由于空间不足而阻塞的写进程

- 当读的数据大于管道中的数据时，先将管道内的数据全部读出然后阻塞等待写进程写入

管道写数据：

- 当管道中有空间时，进程便从写指针位置开始写数据，每写入一个数据地址自动增加，写操作完成后由核心修改写指针，并唤醒所有由于没有内容而阻塞的读进程

##### System V

  IPC机制主要用于各进程运行在各自的虚拟空间，不能够进行直接访问，只能够通过系统提供的进程间通信机制(IPC)进行通信。

| 类型   | 适用范围          |
|:----:|:-------------:|
| 信号量  | 主要用于进程同步控制    |
| 消息队列 | 进程间传递格式化数据    |
| 共享内存 | 多个进程共同访问同一存储区 |

  IPC对象在linux总拥有一个`ipc_perm`数据结构，用来标识IPC

**信号量**

   每一个信号量对象对映一个信号量数组，Linux使用`semid_ds`结构表示，包括：

- ipc_perm结构

- 信号量的数目

- 信号量的最后操作时间和修改时间

- 指向第一个信号量的指针

- 信号量等待队列

- UNDO队列：用于防止死锁

![](https://i.loli.net/2019/12/11/b9QdyNHDiI5AmxR.png)

信号量的操作：

- 值为正：加到信号量的值上，唤醒由该信号量造成的等待进程

- 值为0：进程等待直到信号量为0，但是并不改变信号量的值

- 值为负：若信号量大于该值的绝对值，就用信号量减去绝对值；否则使进程睡眠。

**消息队列**

  Linux中维护一个消息队列链表，每一项指向一个描述消息队列的`msqid_ds`结构，结构包括:

- ipc_perm对象

- 消息队列的头指针

- 消息的最后发送事件、接收时间和修改时间

- 读、写两个等待队列

- 消息的数目和字节数

![](https://i.loli.net/2019/12/11/vfOw9c6sytImhTe.png)

 消息的发送

  进程调用`msgsnd()`发送消息，每当发送消息时，系统将有效uid和gid和`ipc_perm`中的存储权限相比较，如果允许则将消息拷贝到消息队列尾部

> Linux对消息队列中消息的大小和长度有严格限制，当队列中容纳不下的时候先将消息放入到等待队列中，当有空间时该进程被唤醒将消息插入到消息队列中。

  消息的接收

  使用`msgrc()`接收消息，取出队列首部的消息，如果首部没有消息就等待。

**共享内存**

   共享内存的使用必须首先在主存中创建一个共享内存，并把它附加到自己的虚拟地址空间上，然后共享内存的使用方式和虚拟内存的使用方式完全相同。

   当进程不需要共享内存时，应该断开进程和共享内存的连接，但是每个进程断开连接只会影响自己和共享内存的连接，共享内存并不会真正释放；**只有等到最后一个断开后共享内存区才会被释放。**

#### 死锁

  死锁产生的原因：资源竞争和推进顺序非法

  死锁产生的必要条件：

- 互斥访问

- 不可剥夺

- 环路等待

- 请求和保持
  
   解决死锁的方法：

- 死锁的预防

- 死锁的避免

- 死锁的检测

- 死锁的解除

### 线程

  线程之间可以共享堆，但是不可以共享栈。线程分为用户级线程和系统级线程。

用户级线程的同步、调度由用户实现；系统级线程的调度和同步由系统内核实现，但是用户可以通过API进行一定的控制和管理。

**线程VS进程**

- 线程是调度的基本单位；进程是资源分配的基本单位

- 线程切换不需要记录上下文，系统开销小；进程切换需要记录上下文，系统开销大

- 同一进程之间线程通信容易，而进程间通信必须利用通信机制实现

- 都是动态实体，都有生命周期和状态转换

Linux中内核级线程和进程无区别，统一对待。但是内核级线程可以共享父进程的一些资源。

创建进程用`fork`，创建线程用`clone`

```cpp
pthread_creat(&id,NULL,(void*)thread,NULL)
```

创建线程，其中参数的含义如下：

- 第一个参数：指向线程标识符的指针

- 第二个参数：设置线程的属性

- 第三个参数：线程执行的函数

- 第四个参数：运行函数的参数

创建成功返回0；如果返回的不是0则创建失败。创建成功后，新线程运行参数三和参数四确定的函数，原线程继续运行下一行代码。

```cpp
pthread_join(id,NULL)
```

用来等待一个线程的结束，相当于`wait()`。
