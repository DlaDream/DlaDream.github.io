---
layout:     post
title:      LeetCode-有效的括号
subtitle:   LeetCode/利用栈
date:       2019-9-23
author:     Yifeng
header-img: img/post-leetcode-easy.jpg
catalog: true
tags:
     - Oj/LeetCode
---

## 题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 注意空字符串可被认为是有效字符串。



## 示例

```
输入: "()"
输出: true

输入: "()[]{}"
输出: true

输入: "(]"
输出: false

输入: "("
输出: false
```



## 解决方案

​       最简单的方式就是用栈实现，遇到左括号(无论是小左括号、大左括号、中多括号)全部进栈，如果遇到一个右括号，就去判断栈是否为空，如果为空则表示不匹配，返回`false`，否则出栈第一个元素，判断是否匹配，如果不匹配返回`false`,否则继续进行下一个元素的判断。

​      当循环结束的时候，**一定要判断是否栈为空**，如果不为空返回`false`，比如：”（“这种情况；如果为空返回`true`。

```c++
class Solution {
public:
    bool isValid(string s) {
        vector<char> stack;
        for(int i=0;i<s.size();i++){
            if(s[i]=='{'||s[i]=='('||s[i]=='[')
                stack.push_back(s[i]);
            else{
                if(stack.size()==0)
                    return false;
                char top=stack[stack.size()-1];
                stack.pop_back();
                if(top=='('&&s[i]!=')'||top=='{'&&s[i]!='}'||top=='['&&s[i]!=']')
                    return false;
            }
        }
        if(stack.size()==0)
            return true;
        else
            return false;
    }
};
```



> ​    其实我觉得这道题真正有趣的地方在官方解释中的第一种方法：计数器法。这种方法在遇到左括号时+1，遇到右括号时进行判断，如果左括号的数目大于0，则减一，否则返回false；直到遍历结束，然后判断左括号的数目是否相同即可。
>
>    当然，这种方法只适用于单类型括号，如果出现多类型括号则无法处理。这时候我就犯了一个很常见的错误，我觉得你可能也会犯，那就是会产生这样的疑问：
>
>    为什么不为每种类型的括号设置一个计数器呢？
>
>    对，就是这个疑问，错的很典型，因为这样就忽略了**括号的相对位置**。 
>
>    比如：”([)]" 这种形式是错误的，如果只单单的判断括号的数目显然是不行滴。

​    我在看评论时看到一句这样的话：*其实可以增加一个判断：如果栈的深度大于字符串长度的1/2，就返回false。因为当出现这种情况的时候，即使后面的全部匹配，栈也不会为空。*我觉得很聪明，就记录了下来。


  